\section{Systemübersicht}

\subsection{Lösungsstrategie}
Um die verteilte Dokumentenbearbeitung zu ermöglichen, verwenden wir eine Variante von Eventsourcing als Lösungsansatz.
Dabei sollen die eingehenden Änderungen am Dokument als einzelne Commands modelliert werden.
Die eingehenden Commands werden vom Backend verarbeitet und an alle Teilnehmer weitergeleitet.
Konflikte werden dabei auf dem Server gelöst.
Wenn nötig werden dabei zusätzliche Commands generiert, welche die Konflikte auflösen.

\subsection{Technologien und Systemaufbau}

Wir verwenden HTTP-Event Streams als Grundlage für die Kommunikation zwischen dem Backend Server und den Klienten.
Als konkrete Implementation dieser Technologie setzen wir Spring-WebFlux ein.
Die weitere Technologieauswahl orientiert sich an diesem Grundsatz Entscheid.

\subsubsection{Backend Server}
Spring WebFlux ist integriert in das Spring Boot Ökosystem und benötigt daher eine zugrundeliegende JVM\@.
Sprachen die auf der JVM aufbauen, haben den Vorteil, dass sie System Interoperabel sind.

Anstatt Java setzen wir jedoch auf Kotlin als Backend Sprache.
Bis jetzt hat kein Mitglied des Projektteams nennenswerte Erfahrung mit Kotlin und wir möchten diese Gelegenheit nutzen,
die Sprache in einem Projekt näher kennenzulernen.
Wir erwarten die nachfolgenden Vorteile:

\begin{itemize}
    \item Robuste Implementierung dank Null Safety
    \item Weniger Boilerplate und damit übersichtlichere Implementeirung
    \item Effiziente und Übersichtliche Anwendung von Streams
\end{itemize}


\subsubsection{Frontend Clients}
Kein Teammitglied hat bis jetzt vertiefte Erfahrung im Bereich der Frontend-Entwicklung.
Daher setzen wir auf das an der FHNW vermittelte Framework React, um die Clients zu implementieren.
React bietet mit seinem Komponenten-Model eine einfache Abstraktionsmöglichkeit um die Anwendung sauber zu Kapseln.
Die Funktionalen JSX Komponenten scheinen leichtgewichtiger im Vergleich zu den HTML-Template-Ansätzen von Angular oder VueJS\@.
Unser Ziel ist es in diesem Projekt die Kenntnisse in einem Projekt zu vertiefen und die Client-Software möglichst pur funktional zu halten.

Änderungen am Dokument werden auch im Frontend immer als Commands modelliert.
Für die Verarbeitung dieser Commands und das verwalten des Zustands der Client Applikation wird redux verwendet.

\subsubsection{Datenbank System}
Um die kollaborativ erstellten Dokumente zu persistieren und zu verwalten setzen wir auf eine No-SQL Lösung.
Das notwendige Datenmodel lässt sich elegant als \emph{Document} abbilden.
Durch den Einsatz einer No-SQL Lösung kann die Representation der Dokumente über alle Layer der Applikation gleichbleibend beibehalten werden\@.

Konkret wird im Projekt MongoDB als Datenbanksystem verwendet.
Wir haben uns für diese Variante aufgrund der bestehenden reaktiven Integration in das Springframework entschieden.

\clearpage

\begin{figure}
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/TechStack2.drawio}
    \caption{Technologie Stack}
\end{figure}

\subsection{Applikationsprotokoll}
%Netzwerk Protokolle und Payload Format (Ja wir schicken JSON)
In der Folge wird auf die verschiedenen Kanäle und das Applikationsprotokoll eingegangen.

\subsubsection{EventSource}
Für die stetige Verbindung der Clients zum Server abonieren die Clients eine EventSource.
Die EventSource ist eine persistente HTTP Verbindung.
Über diese Verbindung hören alle Clients auf Änderungen, die von anderen Clients gemacht werden.
Dieser Kanal sendet alle Kommandos einzeln an die Clients.
Im Fehlerfall wird ein neuer Initial Command ausgelöst, der das gesamte Dokument an alle Clients verteilt.
Damit wird ein konsistenter Zustand erstellt.
Die EventSource wird auch verwendet, um eine Aussage über die verbundenen Clients machen zu können.

\subsubsection{HTTP}
Die Clients wenden im Frontend alle Commands auf sich selber an und senden danach das Command an den Server.
Dafür gibt es einen HTTP POST Endpunkt, der alle Commands entgegen nimmt.
Intern wird anhand des "type" in der Payload entschieden, wie mit dem Command umgegangen wird.

Die genaue Übersicht der Endpunkte ist im Kapitel "API" zu finden.

Der eigentliche Kanal läuft über HTTPS.

\subsubsection{Applikationsprotokoll}
Die Frontend und Backend kommunizieren über JSON.
Jedes JSON Objekt hat folgenden Aufbau:
\begin{itemize}
    \item type: Der Command Type (Bsp. ADD\_PARAGRAPH)
    \item payload: Ein JSON Objekt welches die Payload für den konkreten type enthält
    \item sender: Eine eindeutige ID des Senders
    \item (opt.) correlationId: Eine zufällige, eindeutige ID
\end{itemize}

\subsection{Benutzerverwaltung}
Es ist keine persistente Benutzerverwaltung mit Registrationsprozess implementiert.
Nach erstmaligem Anmelden in der Applikation mit einem globalen Benutzer, wird ein zufälliger Author erstellt.
Die Daten des Authors werden im Local Storage des Browsers gespeichert, sodass bei erneutem Öffnen der Applikation der gleiche Author wiederverwendet wird.
